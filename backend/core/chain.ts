import { CoinPool } from './coin';
import { Block } from './block';
import { Transaction } from './transaction';

export class Chain {
    /**
     * The chain of blocks starting from the genesis block.
     */
    readonly blocks: Block[] = [Block.GENESIS];

    /**
     * Map of transactions by their hash.
     *
     * This map is used to keep track of all transactions in the blockchain.
     */
    readonly transactionMap: Map<string, Transaction> = new Map();

    /**
     * Pool of coins (UTXOs) corresponding to the addresses in the chain.
     */
    readonly coinPool = new CoinPool();

    /**
     * Size of the chain.
     */
    get size(): number {
        return this.blocks.length;
    }

    /**
     * Size of the transactions.
     */
    get transactionSize(): number {
        return this.transactionMap.size;
    }

    /**
     * Size of the addresses holding coins in the chain.
     */
    get addressSize(): number {
        return this.coinPool.size;
    }

    /**
     * Genesis block (first block in the chain).
     */
    get genesisBlock(): Block {
        return this.blocks[0];
    }

    /**
     * Last block in the chain.
     *
     * Getting the latest block in the blockchain assists in ensuring the hash of the current block
     * points to the hash of the previous block — thus maintaining the chain’s integrity.
     */
    get lastBlock(): Block {
        return this.blocks[this.size - 1];
    }

    /**
     * Next block to be mined.
     */
    get nextBlock(): Block {
        return new Block(this.size, this.lastBlock.hash);
    }

    /**
     * Known wallet addresses in the chain.
     */
    get addresses(): string[] {
        return this.coinPool.keys;
    }

    /**
     * Current block difficulty.
     */
    get difficulty(): number {
        return this.lastBlock.difficulty;
    }

    /**
     * Total amount of coins ever minted and generated by fees.
     */
    get totalSupply(): number {
        return this.coinPool.total;
    }

    /**
     * Maximum amout of coins ever can be minted.
     */
    get maxSupply(): number {
        let total = 0;
        let reward = Block.INITIAL_REWARD;

        // halve reward until it reaches 0
        while (reward > 0) {
            // sum reward multiplied by BLOCK_REWARD_INTERVAL
            total += reward * Block.REWARD_HALVING_INTERVAL;
            reward /= 2; // halve reward
        }

        return total;
    }

    /**
     * Add new block to the blockchain.
     */
    addBlock(block: Block): void {
        this.blocks.push(block);

        // process transactions in the block
        this.#processTransactions(block);
    }

    /**
     * Process transactions in the block.
     *
     * This method is called after a block is added to the chain.
     * It is responsible for updating the coin pool (UTXOs) and transaction map.
     * And also for removing transactions from the pending pools.
     */
    #processTransactions(block: Block): void {
        // loop through all transactions
        block.transactions.map((tx) => {
            // update coin pool
            this.coinPool.update(tx);

            // add to the transaction map
            this.transactionMap.set(tx.hash, tx);

            // set block height for each transaction
            (tx as any).blockHeight = block.index;
        });
    }
}
