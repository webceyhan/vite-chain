import {
    BLOCK_REWARD,
    BLOCK_REWARD_INTERVAL,
    BLOCK_TIME_INTERVAL,
} from '../constants';
import { Block, GENESIS_BLOCK } from './block';
import { Transaction } from './transaction';
import { CoinPool } from './coin';
import { delay } from '../utils';
import EventEmitter from 'events';

export type ChainEvent =
    | 'chain:updated'
    | 'block:mined'
    | 'block:added'
    | 'supply:changed'
    | 'transaction:added'
    | 'transaction:discarded';

export class Chain {
    /**
     * Miner wallet address to collect block rewards.
     */
    public readonly minerAddress: string;

    /**
     * The chain of blocks starting from the genesis block.
     */
    public blocks: Readonly<Block>[] = [GENESIS_BLOCK];

    /**
     * Map of transactions by their hash.
     *
     * This map is used to keep track of all transactions in the blockchain.
     */
    private transactionMap: Map<string, Readonly<Transaction>> = new Map();

    /**
     * Pool of coins (UTXOs) corresponding to the addresses in the chain.
     */
    private readonly coinPool = new CoinPool();

    /**
     * Pending transactions to be added to the next block.
     */
    private pendingTransactions: Readonly<Transaction>[] = [];

    /**
     * Pending pool of coins (UTXOs) corresponding to the addresses in the chain.
     * This is used to check if a pending transaction is valid (has sufficient funds).
     */
    private pendingCoinPool = new CoinPool();

    /**
     * Internal event emitter.
     */
    private eventEmitter = new EventEmitter();

    constructor(minerAddress: string) {
        // set miner wallet address
        this.minerAddress = minerAddress;
    }

    /**
     * Size of the chain.
     */
    get size(): number {
        return this.blocks.length;
    }

    /**
     * Size of the transactions.
     */
    get transactionSize(): number {
        return this.transactionMap.size;
    }

    /**
     * Size of the addresses holding coins in the chain.
     */
    get addressSize(): number {
        return this.coinPool.size;
    }

    /**
     * Genesis block (first block in the chain).
     */
    get genesisBlock(): Block {
        return this.blocks[0];
    }

    /**
     * Last block in the chain.
     *
     * Getting the latest block in the blockchain assists in ensuring the hash of the current block
     * points to the hash of the previous block — thus maintaining the chain’s integrity.
     */
    get lastBlock(): Block {
        return this.blocks[this.size - 1];
    }

    /**
     * Next block to be mined.
     */
    get nextBlock(): Block {
        return new Block(
            this.size,
            this.lastBlock.hash,
            this.pendingTransactions,
            this.lastBlock.difficulty
        );
    }

    /**
     * Known wallet addresses in the chain.
     */
    get addresses(): string[] {
        return this.coinPool.keys;
    }

    /**
     * Current block difficulty.
     */
    get difficulty(): number {
        return this.lastBlock.difficulty;
    }

    /**
     * Total amount of coins ever minted and generated by fees.
     */
    get totalSupply(): number {
        return this.coinPool.total;
    }

    /**
     * Maximum amout of coins ever can be minted.
     */
    get maxSupply(): number {
        let total = 0;
        let reward = BLOCK_REWARD;

        // halve reward until it reaches 0
        while (reward > 0) {
            // sum reward multiplied by BLOCK_REWARD_INTERVAL
            total += reward * BLOCK_REWARD_INTERVAL;
            reward /= 2; // halve reward
        }

        return total;
    }

    /**
     * Add new transaction to the blockchain.
     */
    addTransaction(tx: Transaction): void {
        // todo: validate transaction
        try {
            // try updating the pending coin pool
            this.pendingCoinPool.transact(tx);

            // add to the pending transactions
            this.pendingTransactions.push(tx);

            // emit transaction:added event
            this.emit('transaction:added', tx);
        } catch (error) {
            // emit transaction:discarded event
            this.emit('transaction:discarded', tx, error);
        }
    }

    /**
     * Add new block to the blockchain.
     */
    addBlock(block: Block): void {
        // todo: validate block
        this.blocks.push(block);

        // process transactions in the block
        this.processTransactions(block);

        // emit block:added event
        this.emit('block:added', block);
    }

    // MINING //////////////////////////////////////////////////////////////////////////////////////

    /**
     * Start mining loop.
     */
    async startMiningLoop() {
        // await for interval to pass
        await delay(BLOCK_TIME_INTERVAL);

        // mine next block
        this.mineBlock();

        // repeat mining loop
        this.startMiningLoop();
    }

    /**
     * Create a new block and add it to the chain.
     */
    private mineBlock() {
        // get next block to mine
        const block = this.nextBlock;

        // add coinbase transaction
        this.addCoinbaseTransaction(block);

        // compute proof-of-work mechanism
        this.computeProofOfWork(block);

        // emit block:mined event
        this.emit('block:mined', block);

        // add block to chain
        this.addBlock(block);
    }

    /**
     * Add coinbase transaction to the block.
     */
    private addCoinbaseTransaction(block: Block): void {
        // create coinbase transaction
        const coinbaseTx = new Transaction(
            '0',
            this.minerAddress,
            block.reward
        );

        // add to the beginning of the block
        block.transactions.unshift(coinbaseTx);
    }

    /**
     * Process transactions in the block.
     *
     * This method is called after a block is added to the chain.
     * It is responsible for updating the coin pool (UTXOs) and transaction map.
     * And also for removing transactions from the pending pools.
     */
    private processTransactions(block: Block): void {
        // loop through all transactions
        block.transactions.map((tx) => {
            // update coin pool
            this.coinPool.transact(tx);

            // add to the transaction map
            this.transactionMap.set(tx.hash, tx);

            // set block height for each transaction
            (tx as any).blockHeight = block.index;
        });

        // reset pending transactions
        this.pendingTransactions = [];

        // reset pending coin pool to the current coin pool
        this.pendingCoinPool = this.coinPool.clone();

        // emit supply:changed event
        this.emit('supply:changed', this.coinPool);
    }

    // CONSENSUS ///////////////////////////////////////////////////////////////////////////////////

    /**
     * Try to guess the nonce of the block until it finds
     * a valid hash that satisfies the difficulty level.
     */
    computeProofOfWork(block: Block): void {
        // define proof string based on zeros
        // e.g. if difficulty is 3, then proof string will be '000'
        const prefix = '0x' + '0'.repeat(block.difficulty);

        // loop until valid proof is found
        while (!block.hash.startsWith(prefix)) {
            // increment nonce
            block.nonce++;

            // reset hash to recalculate
            block.resetHash();
        }
    }

    // EVENT EMITTER METHODS ///////////////////////////////////////////////////////////////////////

    /**
     * Emit chain event.
     */
    emit(eventName: ChainEvent, ...args: any[]): void {
        // emit provided event with arguments
        this.eventEmitter.emit(eventName, ...args);

        // emit chain:updated event
        this.eventEmitter.emit('chain:updated', this);
    }

    /**
     * Add chain event listener.
     */
    on(eventName: ChainEvent, listener: (...args: any[]) => void): void {
        this.eventEmitter.on(eventName, listener);
    }

    /**
     * Remove chain event listener.
     */
    off(eventName: ChainEvent, listener: (...args: any[]) => void): void {
        this.eventEmitter.off(eventName, listener);
    }

    // QUERY METHODS ///////////////////////////////////////////////////////////////////////////////

    /**
     * Find block by hash.
     */
    findBlock(hash: string): Block | never {
        const block = this.blocks.find((block) => block.hash === hash);

        if (block) return block; // return if found or throw error
        throw new Error(`Block with hash ${hash} not found.`);
    }

    /**
     * Find block by height.
     */
    findBlockByHeight(height: number): Block | never {
        // return if found or throw error
        if (this.blocks[height]) return this.blocks[height];
        throw new Error(`Block with height ${height} not found.`);
    }

    /**
     * Find transaction by hash.
     */
    findTransaction(hash: string): Transaction | never {
        const tx = this.transactionMap.get(hash);

        if (tx) return tx; // return if found or throw error
        throw new Error(`Transaction with hash ${hash} not found.`);
    }

    /**
     * Find all transaction by address.
     */
    findTransactionsByAddress(address: string): Transaction[] {
        const transactions: Transaction[] = [];

        // loop through all transactions
        this.transactionMap.forEach((tx) => {
            if (tx.from === address) transactions.push(tx);
            if (tx.to === address) transactions.push(tx);
        });

        return transactions;
    }

    /**
     * Find balance of the given address.
     */
    findBalance(address: string): number {
        return this.coinPool.getBalance(address);
    }
}
