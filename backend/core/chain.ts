import { CoinPool } from './coin';
import { Block } from './block';
import { Transaction } from './transaction';

export class Chain {
    /**
     * Coin symbol of the chain.
     */
    static readonly SYMBOL = 'VTC';

    /**
     * The chain of blocks starting from the genesis block.
     */
    readonly blocks: Block[] = [Block.GENESIS];

    /**
     * Map of transactions by their hash.
     *
     * This map is used to keep track of all transactions in the blockchain.
     */
    readonly transactionMap: Map<string, Transaction> = new Map();

    /**
     * Pool of coins (UTXOs) corresponding to the addresses in the chain.
     */
    readonly coinPool = new CoinPool();

    /**
     * Size of the chain.
     */
    get size(): number {
        return this.blocks.length;
    }

    /**
     * Size of the transactions.
     */
    get transactionSize(): number {
        return this.transactionMap.size;
    }

    /**
     * Size of the addresses holding coins in the chain.
     */
    get addressSize(): number {
        return this.coinPool.size;
    }

    /**
     * Genesis block (first block in the chain).
     */
    get genesisBlock(): Block {
        return this.blocks[0];
    }

    /**
     * Last block in the chain.
     *
     * Getting the latest block in the blockchain assists in ensuring the hash of the current block
     * points to the hash of the previous block — thus maintaining the chain’s integrity.
     */
    get lastBlock(): Block {
        return this.blocks[this.size - 1];
    }

    /**
     * Next block to be mined.
     */
    get nextBlock(): Block {
        return new Block(this.size, this.lastBlock.hash, [], this.difficulty);
    }

    /**
     * Known wallet addresses in the chain.
     */
    get addresses(): string[] {
        return this.coinPool.keys;
    }

    /**
     * Total amount of coins ever minted and generated by fees.
     */
    get totalSupply(): number {
        return this.coinPool.total;
    }

    /**
     * Maximum amout of coins ever can be minted.
     */
    get maxSupply(): number {
        let total = 0;
        let reward = Block.INITIAL_REWARD;

        // halve reward until it reaches 0
        while (reward > 0) {
            // sum reward multiplied by BLOCK_REWARD_INTERVAL
            total += reward * Block.REWARD_HALVING_INTERVAL;
            reward /= 2; // halve reward
        }

        return total;
    }

    /**
     * Current block difficulty.
     */
    get difficulty(): number {
        // extract index, difficulty from last block
        const { index, difficulty } = this.lastBlock;

        // define flag to check if difficulty adjustment is needed
        // if index is greater than zero (not genesis block)
        // and index is a multiple of DIFFICULTY_ADJUSTMENT_INTERVAL
        const canAdjust =
            index > 0 && index % Block.DIFFICULTY_ADJUSTMENT_INTERVAL === 0;

        // return adjusted difficulty if needed
        return canAdjust ? this.#adjustedDifficulty : difficulty;
    }

    /**
     * Adjusted difficulty based on the current block index.
     */
    get #adjustedDifficulty(): number {
        // extract difficulty, timestamp from last adjusted block
        const { difficulty, timestamp } =
            this.blocks[this.size - Block.DIFFICULTY_ADJUSTMENT_INTERVAL];

        // calculate the expected time to mine the next block
        const timeExpected =
            Block.MINING_TIME_INTERVAL *
            Block.DIFFICULTY_ADJUSTMENT_INTERVAL *
            1000; // convert to milliseconds

        // calculate time difference between current and last adjusted block
        const timeTaken = this.lastBlock.timestamp - timestamp;

        // increase difficulty if taken time was too quick
        if (timeTaken < timeExpected / 2) return difficulty + 1;
        // decrease difficulty if taken time was too slow (no below zero)
        else if (timeTaken > timeExpected * 2) return (difficulty || 1) - 1;
        // return difficulty if time was just right
        else return difficulty;
    }

    /**
     * Add new block to the blockchain.
     */
    addBlock(block: Block): void {
        this.blocks.push(block);

        // process transactions in the block
        this.#processTransactions(block);
    }

    /**
     * Process transactions in the block.
     *
     * This method is called after a block is added to the chain.
     * It is responsible for updating the coin pool (UTXOs) and transaction map.
     * And also for removing transactions from the pending pools.
     */
    #processTransactions(block: Block): void {
        // loop through all transactions
        block.transactions.map((tx) => {
            // update coin pool
            this.coinPool.update(tx);

            // add to the transaction map
            this.transactionMap.set(tx.hash, tx);

            // set block height for each transaction
            (tx as any).blockHeight = block.index;
        });
    }
}
